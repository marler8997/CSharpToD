
Objects and Exceptions
--------------------------------------------------------------------------------
CSharpToD rewrites all references to System.Object and System.Exception to
System.DotNetObject and System.DotNetException.  This is because the `Object`
and `Exception` type names are reserved in D.  The current technique uses the
DotNetObject and DotNetException as type to "thunk" .NET types to D type.


Fields with the same name as their Type
--------------------------------------------------------------------------------
```C#
class SomeClass
{
}
class Foo
{
    SomeClass SomeClass; // Allowed in .NET, not allowed in D
}
```
```D
class SomeClass
{
}
class Foo
{
    SomeClass SomeClass_; // Append a '_' to the end of the name
}
```

Generics to Templates
--------------------------------------------------------------------------------
```C#
class Foo { }
class Foo<T> { }
class Foo<T,K> { }
```
```D
class Foo { }
class Foo1(T) { }
class Foo2(T,K) { }
```
.NET Generics are converted to D templates.  The caveat is that the number of
generic arguments is appended to the symbol name.  This is because classes and
templates cannot share names.  This problem could have been resolved by making
all classes templates, but then you would have to include an empty template
parameter list any time you wanted to use the non-generic version.

Namespaces To Modules
--------------------------------------------------------------------------------
In D, all code is located within a module, and every module has a one-to-one
correspondance with the file system.

```D
// File: /sompath/org/util.d
module org.util;

// code here
```

In this example, no other file can have the module name org.util.

.NET works a little differently.  Instead of modules, it has namespacs.
Namespaces in .NET do not necessarily have any correspondance with the file
system.  Any namespace can appear in any file in any project.
```C#
namespace Org.Util
{
  // code here
}
namespace Org.Another
{
  // more code here
}
```

One of the main benefits of modules/namespaces is it allows you to reference
a symbol in another module/namespace without having to type the fully-qualified
name.  The D code generated by CSharpToD maintains this benefit.  This means that
when .NET code is translated, the code is reorganized so that all code in the
same namespace goes in the same module. This means the code will probably move
into a different file then it originally appeared.  The caveat with this is that
any code that shares the same namespace will either need to be converted together,
or you will need to specify SubPackage names (see below).

### Example
```
/mycode/cs2d.config
/mycode/MyOrg/LibraryA/LibraryA.csproj // contains namespaces MyOrg and MyOrg.LibraryA
/mycode/MyOrg/LibraryB/LibraryB.csproj // contains namespaces MyOrg and MyOrg.LibraryB

// Converted Code
/mycode/cs2d/MyOrg/package.d   // Code in MyOrg namespace
/mycode/cs2d/MyOrg/LibraryA.d  // Code in MyOrg.LibraryA namespace
/mycode/cs2d/MyOrg/LibraryB.d  // Code in MyOrg.LibraryB namespace
```

### Converting Different Code Bases that Share Namespaces

If you have multiple code bases that share namespaces and cannot be converted
together, then the current solution is to put each code base in their own D
sub-package.  So when all the namespaces in a package get converted to D modules,
the names will be prefixed by their SubPackageName.  This can be configured in
the cs2d.config file:
```
SubPackageName foo
```
So let's say you are using mscorlib, but you have your own code that uses some
of the same namespaces in mscorlib.
```C#
namespace System
{
    // some stuff that I think should be in the System namespace
}
```
Then if you configure the SubPackageName to "MyStuff", this will get converted
to the D module "MyStuff.System":
```
/cs2d/MyStuff/System.d
```

That way, when a project needs to reference mscorlib and your custom package,
it can:
```D
import System;
import MyStuff.System;
```

The `internal` modifier
--------------------------------------------------------------------------------
C# supports the `internal` modifier which makes the code visible to the current
assembly only. However, cs2d has no concept of assemblies. So cs2d treats
`internal` the same as `public`.  This should allow all converted code to work,
but may cause extra types to be visible that were not intended to be.

Struct Interfaces
--------------------------------------------------------------------------------
.NET structs can implement interfaces, but D interfaces cannot. The way .NET
implements struct interfaces is through boxing.  Whenever a struct is assigned
to an interface, a copy is created on the heap, this is called "boxing".

To support this in D, every struct that implements .NET interfaces will have
an extra type definition.  For exampe, if `SomeInterface` exists, the following
C# code:
```C#
struct SomeStruct : SomeInterface
{
}
```
would be converted to the following D code:
```D
struct SomeStruct
{
}
class __Boxed__SomeStruct : SomeInterface
{
    SomeStruct value;
    alias this value;
}
```

Empty Enums
--------------------------------------------------------------------------------
.NET supports enum definitions with no values, but D does not.  If this happens,
a value of `__no_values__` will be inserted.
