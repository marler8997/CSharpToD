
Conversion Tree
--------------------------------------------------------------------------------
A conversion tree is a directory that contains all the .NET projects that will
be converted "together" into D.  The root of the conversion tree is marked by
the precense of a cs2d.config file. Take the following example:
```
/workspace/cs2d.config
/workspace/ProjectA/...
/workspace/ProjectB/...
```

In this case, `/workspace` is the root of the conversion tree. This means that
cs2d will generated the converted code in `/workspace/cs2d`.

One reason for conversion trees is to aleviate the inconsistencies with .NET
namespace and D modules (See #Namespaces-To-Modules).

Namespaces To Modules
--------------------------------------------------------------------------------
In D, all code is located within a module, and every module has a one-to-one
correspondance with the file system.

```D
// File: /sompath/org/util.d
module org.util;

// code here
```

In this example, no other file can have the module name org.util.

.NET works a little differently.  Instead of modules, it has namespacs.
Namespaces in .NET do not necessarily have any correspondance with the file
system.  Any namespace can appear in any file in any project.
```C#
namespace Org.Util
{
  // code here
}
namespace Org.Another
{
  // more code here
}
```

One of the main benefits of modules/namespaces is it allows you to reference
a symbol in another module/namespace without having to type the fully-qualified
name.  The D code generated by cs2d maintains this benefit.  Because of this,
when .NET code is translated, the code is reorganized so that all code in the
same namespace goes in the same module. The caveat is that any code that shares
a namespace, must be within the same conversion tree, so that cs2d can put them
in the same D module.

### Example
```
/mycode/cs2d.config
/mycode/MyOrg/LibraryA/LibraryA.csproj // contains namespaces MyOrg and MyOrg.LibraryA
/mycode/MyOrg/LibraryB/LibraryB.csproj // contains namespaces MyOrg and MyOrg.LibraryB

// Converted Code
/mycode/cs2d/MyOrg/package.d   // Code in MyOrg namespace
/mycode/cs2d/MyOrg/LibraryA.d  // Code in MyOrg.LibraryA namespace
/mycode/cs2d/MyOrg/LibraryB.d  // Code in MyOrg.LibraryB namespace
```

The `internal` modifier
--------------------------------------------------------------------------------
C# supports the `internal` modifier which makes the code visible to the current
assembly only. However, cs2d has no concept of assemblies. So cs2d treats
`internal` the same as `public`.  This should allow all converted code to work,
but may cause extra types to be visible that were not intended to be.

Struct Interfaces
--------------------------------------------------------------------------------
.NET structs can implement interfaces, but D interfaces cannot. The way .NET
implements struct interfaces is through boxing.  Whenever a struct is assigned
to an interface, a copy is created on the heap, this is called "boxing".

To support this in D, every struct that implements .NET interfaces will have
an extra type definition.  For exampe, if `SomeInterface` exists, the following
C# code:
```C#
struct SomeStruct : SomeInterface
{
}
```
would be converted to the following D code:
```D
struct SomeStruct
{
}
class __Boxed__SomeStruct : SomeInterface
{
    SomeStruct value;
    alias this value;
}
```

Empty Enums
--------------------------------------------------------------------------------
.NET supports enum definitions with no values, but D does not.  If this happens,
a value of `__no_values__` will be inserted.
